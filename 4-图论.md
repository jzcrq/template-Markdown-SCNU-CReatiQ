# 图论

## 强连通分量

```cpp
struct SCC
{
	int n,cur,cnt;
	vector<vector<int>> adj;
	vector<int> stk,dfn,low,bel;

	SCC() {}
	SCC(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		adj.assign(n,{});
		stk.clear();
		dfn.assign(n,-1);
		low.resize(n);
		bel.assign(n,-1);
		cur=cnt=0;
	}

	void add(int u,int v) { adj[u].push_back(v); }

	void dfs(int x)
	{
		dfn[x]=low[x]=cur++;
		stk.push_back(x);
		for (auto y:adj[x])
		{
			if (dfn[y]==-1)
			{
				dfs(y);
				low[x]=min(low[x],low[y]);
			}
			else if (bel[y]==-1) low[x]=min(low[x],dfn[y]);
		}
		if (dfn[x]==low[x])
		{
			int y;
			do
			{
				y=stk.back();
				bel[y]=cnt;
				stk.pop_back();
			} while (y!=x);
			cnt++;
		}
	}

	vector<int> work()
	{
		for (int i=0;i<n;i++)
			if (dfn[i]==-1) dfs(i);
		return bel;
	}

	struct Graph
	{
		int n;
		vector<pair<int,int>> edges;
		vector<int> siz,cnte;
	};

	Graph compress()
	{
		Graph G;
		G.n=cnt;
		G.siz.resize(cnt);
		G.cnte.resize(cnt);
		for (int i=0;i<n;i++)
		{
			G.siz[bel[i]]++;
			for (auto j:adj[i])
				if (bel[i]!=bel[j])
					G.edges.emplace_back(bel[j],bel[i]);
		}
		return G;
	};
};
```

## 边双连通分量

```cpp
struct EBCC
{
	int n;
	vector<vector<int>> adj;
	vector<int> stk,dfn,low,bel;
	int cur,cnt;

	EBCC() {}
	EBCC(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		adj.assign(n,{});
		dfn.assign(n,-1);
		low.resize(n);
		bel.assign(n,-1);
		stk.clear();
		cur=cnt=0;
	}

	void add(int u,int v)
	{
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void dfs(int x,int p)
	{
		dfn[x]=low[x]=cur++;
		stk.push_back(x);
		for (auto y:adj[x])
		{
			if (y==p) continue;
			if (dfn[y]==-1)
			{
				dfs(y,x);
				low[x]=min(low[x],low[y]);
			}
			else if (bel[y]==-1&&dfn[y]<dfn[x]) low[x]=min(low[x],dfn[y]);
		}
		if (dfn[x]==low[x])
		{
			int y;
			do
			{
				y=stk.back();
				bel[y]=cnt;
				stk.pop_back();
			} while (y!=x);
			cnt++;
		}
	}

	vector<int> work()
	{
		dfs(0,-1);
		return bel;
	}

	struct Graph
	{
		int n;
		vector<pair<int,int>> edges;
		vector<int> siz,cnte;
	};

	Graph compress()
	{
		Graph G;
		G.n=cnt;
		G.siz.resize(cnt);
		G.cnte.resize(cnt);
		for (int i=0;i<n;i++)
		{
			G.siz[bel[i]]++;
			for (auto j:adj[i])
			{
				if (bel[i]<bel[j]) G.edges.emplace_back(bel[i],bel[j]);
				else if (i<j) G.cnte[bel[i]]++;
			}
		}
		return G;
	};
};
```

## 轻重链剖分

```cpp
struct HLD
{
	int n;
	vector<int> siz,top,dep,pa,in,out,seq;
	vector<vector<int>> adj;
	int cur;

	HLD(){}
	HLD(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		siz.resize(n);
		top.resize(n);
		dep.resize(n);
		pa.resize(n);
		in.resize(n);
		out.resize(n);
		seq.resize(n);
		cur=0;
		adj.assign(n,{});
	}

	void addEdge(int u,int v)
	{
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void work(int rt=0)
	{
		top[rt]=rt;
		dep[rt]=0;
		pa[rt]=-1;
		dfs1(rt);
		dfs2(rt);
	}

	void dfs1(int u)
	{
		if (pa[u]!=-1) adj[u].erase(find(adj[u].begin(),adj[u].end(),pa[u]));
		siz[u]=1;
		for (auto &v:adj[u])
		{
			pa[v]=u;
			dep[v]=dep[u]+1;
			dfs1(v);
			siz[u]+=siz[v];
			if (siz[v]>siz[adj[u][0]])
				swap(v,adj[u][0]);
		}
	}

	void dfs2(int u)
	{
		in[u]=cur++;
		seq[in[u]]=u;
		for (auto v:adj[u])
		{
			top[v]=(v==adj[u][0])?top[u]:v;
			dfs2(v);
		}
		out[u]=cur;
	}

	int lca(int u,int v)
	{
		while (top[u]!=top[v])
		{
			if (dep[top[u]]>dep[top[v]]) u=pa[top[u]];
			else v=pa[top[v]];
		}
		return dep[u]<dep[v]?u:v;
	}

	int dist(int u,int v) { return dep[u]+dep[v]-(dep[lca(u,v)]<<1); }

	int jump(int u,int k)
	{
		if (dep[u]<k) return -1;
		int d=dep[u]-k;
		while (dep[top[u]]>d) u=pa[top[u]];
		return seq[in[u]-dep[u]+d];
	}

	bool isAncester(int u,int v) { return in[u]<=in[v]&&in[v]<out[u]; }

	int rootedParent(int u,int v)//u->root,v->point
	{
		if (u==v) return u;
		if (!isAncester(v,u)) return pa[v];
		auto it=upper_bound(adj[v].begin(),adj[v].end(),u,[&](int x,int y){ return in[x]<in[y]; })-1;
		return *it;
	}

	int rootedSize(int u,int v)//same as rootedParent
	{
		if (u==v) return n;
		if (!isAncester(v,u)) return siz[v];
		return n-siz[rootedParent(u,v)];
	}

	int rootedLca(int a,int b,int c) { return lca(a,b)^lca(b,c)^lca(c,a); }
};
```

## 2-SAT

```cpp
struct TwoSat
{
	int n;
	vector<vector<int>> e;
	vector<bool> ans;

	TwoSat(int n):n(n),e(n<<1),ans(n){}

	void addClause(int u,bool f,int v,bool g)
	{
		e[u*2+!f].push_back(v*2+g);
		e[v*2+!g].push_back(u*2+f);
	}

	bool satisfiable()
	{
		vector<int> id(n*2,-1),dfn(n*2,-1),low(n*2,-1),stk;
		int now=0,cnt=0;
		function<void(int)> tarjan=[&](int u)
		{
			stk.push_back(u);
			dfn[u]=low[u]=now++;
			for (auto v:e[u])
			{
				if (dfn[v]==-1)
				{
					tarjan(v);
					low[u]=min(low[u],low[v]);
				}
				else if (id[v]==-1)
					low[u]=min(low[u],dfn[v]);
			}
			if (dfn[u]==low[u])
			{
				int v;
				do
				{
					v=stk.back();
					stk.pop_back();
					id[v]=cnt;
				} while (v!=u);
				cnt++;
			}
		};
		for (int i=0;i<n*2;i++)
			if (dfn[i]==-1)
				tarjan(i);
		for (int i=0;i<n;i++)
		{
			if (id[i*2]==id[i*2+1]) return 0;
			ans[i]=id[i*2]>id[i*2+1];
		}
		return 1;
	}
	vector<bool> answer() { return ans; }
};
```
