# 图论

## Dijkstra

注意设定合适的 $\text{inf}$。
```cpp
//注意设定合适的inf
vector<i64> dijk(const vector<vector<pair<int,i64>>> &adj,int s)
{
	int n=adj.size();
	using pa=pair<i64,int>;
	vector<i64> d(n,inf);
	vector<int> ed(n);
	priority_queue<pa,vector<pa>,greater<pa>> q;
	q.push({0,s}); d[s]=0;
	while (!q.empty())
	{
		int u=q.top().second;
		q.pop();
		ed[u]=1;
		for (auto [v,w]:adj[u])
			if (d[u]+w<d[v])
			{
				d[v]=d[u]+w;
				q.push({d[v],v});
			}
		while (!q.empty()&&ed[q.top().second]) q.pop();
	}
	return d;
}
```

## SPFA

注意设定合适的 $\text{inf}$。
```cpp
vector<i64> spfa(const vector<vector<pair<int,i64>>> &adj,int s)
{
	int n=adj.size();
	assert(n);
	queue<int> q;
	vector<int> len(n),ed(n);
	vector<i64> d(n,inf);
	q.push(s); d[s]=0;
	while (!q.empty())
	{
		int u=q.front();
		q.pop();
		ed[u]=0;
		for (auto [v,w]:adj[u])
			if (d[u]+w<d[v])
			{
				d[v]=d[u]+w;
				len[v]=len[u]+1;
				if (len[v]>n) return {};
				if (!ed[v]) ed[v]=1,q.push(v);
			}
	}
	return d;
}
```

## 强连通分量

```cpp
struct SCC
{
	int n,cur,cnt;
	vector<vector<int>> adj;
	vector<int> stk,dfn,low,bel;

	SCC() {}
	SCC(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		adj.assign(n,{});
		stk.clear();
		dfn.assign(n,-1);
		low.resize(n);
		bel.assign(n,-1);
		cur=cnt=0;
	}

	void add(int u,int v) { adj[u].push_back(v); }

	void dfs(int x)
	{
		dfn[x]=low[x]=cur++;
		stk.push_back(x);
		for (auto y:adj[x])
		{
			if (dfn[y]==-1)
			{
				dfs(y);
				low[x]=min(low[x],low[y]);
			}
			else if (bel[y]==-1) low[x]=min(low[x],dfn[y]);
		}
		if (dfn[x]==low[x])
		{
			int y;
			do
			{
				y=stk.back();
				bel[y]=cnt;
				stk.pop_back();
			} while (y!=x);
			cnt++;
		}
	}

	vector<int> work()
	{
		for (int i=0;i<n;i++)
			if (dfn[i]==-1) dfs(i);
		return bel;
	}

	struct Graph
	{
		int n;
		vector<pair<int,int>> edges;
		vector<int> siz,cnte;
	};

	Graph compress()
	{
		Graph G;
		G.n=cnt;
		G.siz.resize(cnt);
		G.cnte.resize(cnt);
		for (int i=0;i<n;i++)
		{
			G.siz[bel[i]]++;
			for (auto j:adj[i])
				if (bel[i]!=bel[j])
					G.edges.emplace_back(bel[j],bel[i]);
		}
		return G;
	};
};
```

## 边双连通分量

```cpp
struct EBCC
{
	int n;
	vector<vector<int>> adj;
	vector<int> stk,dfn,low,bel;
	int cur,cnt;

	EBCC() {}
	EBCC(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		adj.assign(n,{});
		dfn.assign(n,-1);
		low.resize(n);
		bel.assign(n,-1);
		stk.clear();
		cur=cnt=0;
	}

	void add(int u,int v)
	{
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void dfs(int x,int p)
	{
		dfn[x]=low[x]=cur++;
		stk.push_back(x);
		for (auto y:adj[x])
		{
			if (y==p) continue;
			if (dfn[y]==-1)
			{
				dfs(y,x);
				low[x]=min(low[x],low[y]);
			}
			else if (bel[y]==-1&&dfn[y]<dfn[x]) low[x]=min(low[x],dfn[y]);
		}
		if (dfn[x]==low[x])
		{
			int y;
			do
			{
				y=stk.back();
				bel[y]=cnt;
				stk.pop_back();
			} while (y!=x);
			cnt++;
		}
	}

	vector<int> work()
	{
		dfs(0,-1);
		return bel;
	}

	struct Graph
	{
		int n;
		vector<pair<int,int>> edges;
		vector<int> siz,cnte;
	};

	Graph compress()
	{
		Graph G;
		G.n=cnt;
		G.siz.resize(cnt);
		G.cnte.resize(cnt);
		for (int i=0;i<n;i++)
		{
			G.siz[bel[i]]++;
			for (auto j:adj[i])
			{
				if (bel[i]<bel[j]) G.edges.emplace_back(bel[i],bel[j]);
				else if (i<j) G.cnte[bel[i]]++;
			}
		}
		return G;
	};
};
```

## 轻重链剖分

```cpp
struct HLD
{
	int n;
	vector<int> siz,top,dep,pa,in,out,seq;
	vector<vector<int>> adj;
	int cur;

	HLD(){}
	HLD(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		siz.resize(n);
		top.resize(n);
		dep.resize(n);
		pa.resize(n);
		in.resize(n);
		out.resize(n);
		seq.resize(n);
		cur=0;
		adj.assign(n,{});
	}

	void addEdge(int u,int v)
	{
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	void work(int rt=0)
	{
		top[rt]=rt;
		dep[rt]=0;
		pa[rt]=-1;
		dfs1(rt);
		dfs2(rt);
	}

	void dfs1(int u)
	{
		if (pa[u]!=-1) adj[u].erase(find(adj[u].begin(),adj[u].end(),pa[u]));
		siz[u]=1;
		for (auto &v:adj[u])
		{
			pa[v]=u;
			dep[v]=dep[u]+1;
			dfs1(v);
			siz[u]+=siz[v];
			if (siz[v]>siz[adj[u][0]])
				swap(v,adj[u][0]);
		}
	}

	void dfs2(int u)
	{
		in[u]=cur++;
		seq[in[u]]=u;
		for (auto v:adj[u])
		{
			top[v]=(v==adj[u][0])?top[u]:v;
			dfs2(v);
		}
		out[u]=cur;
	}

	int lca(int u,int v)
	{
		while (top[u]!=top[v])
		{
			if (dep[top[u]]>dep[top[v]]) u=pa[top[u]];
			else v=pa[top[v]];
		}
		return dep[u]<dep[v]?u:v;
	}

	int dist(int u,int v) { return dep[u]+dep[v]-(dep[lca(u,v)]<<1); }

	int jump(int u,int k)
	{
		if (dep[u]<k) return -1;
		int d=dep[u]-k;
		while (dep[top[u]]>d) u=pa[top[u]];
		return seq[in[u]-dep[u]+d];
	}

	bool isAncester(int u,int v) { return in[u]<=in[v]&&in[v]<out[u]; }

	int rootedParent(int u,int v)//u->root,v->point
	{
		if (u==v) return u;
		if (!isAncester(v,u)) return pa[v];
		auto it=upper_bound(adj[v].begin(),adj[v].end(),u,[&](int x,int y){ return in[x]<in[y]; })-1;
		return *it;
	}

	int rootedSize(int u,int v)//same as rootedParent
	{
		if (u==v) return n;
		if (!isAncester(v,u)) return siz[v];
		return n-siz[rootedParent(u,v)];
	}

	int rootedLca(int a,int b,int c) { return lca(a,b)^lca(b,c)^lca(c,a); }
};
```

## 2-SAT

```cpp
struct TwoSat
{
	int n;
	vector<vector<int>> e;
	vector<bool> ans;

	TwoSat(int n):n(n),e(n<<1),ans(n){}

	void addClause(int u,bool f,int v,bool g)
	{
		e[u*2+!f].push_back(v*2+g);
		e[v*2+!g].push_back(u*2+f);
	}

	bool satisfiable()
	{
		vector<int> id(n*2,-1),dfn(n*2,-1),low(n*2,-1),stk;
		int now=0,cnt=0;
		function<void(int)> tarjan=[&](int u)
		{
			stk.push_back(u);
			dfn[u]=low[u]=now++;
			for (auto v:e[u])
			{
				if (dfn[v]==-1)
				{
					tarjan(v);
					low[u]=min(low[u],low[v]);
				}
				else if (id[v]==-1)
					low[u]=min(low[u],dfn[v]);
			}
			if (dfn[u]==low[u])
			{
				int v;
				do
				{
					v=stk.back();
					stk.pop_back();
					id[v]=cnt;
				} while (v!=u);
				cnt++;
			}
		};
		for (int i=0;i<n*2;i++)
			if (dfn[i]==-1)
				tarjan(i);
		for (int i=0;i<n;i++)
		{
			if (id[i*2]==id[i*2+1]) return 0;
			ans[i]=id[i*2]>id[i*2+1];
		}
		return 1;
	}
	vector<bool> answer() { return ans; }
};
```

## 最大流

```cpp
template <class T>
struct MaxFlow
{
	struct _Edge
	{
		int to;
		T cap;
		_Edge(int to,T cap):to(to),cap(cap){}
	};

	int n;
	vector<_Edge> e;
	vector<vector<int>> g;
	vector<int> cur,h;

	MaxFlow(){}
	MaxFlow(int n) { init(n); }

	void init(int n)
	{
		this->n=n;
		e.clear();
		g.assign(n,{});
		cur.resize(n);
		h.resize(n);
	}

	bool bfs(int s,int t)
	{
		h.assign(n,-1);
		queue<int> que;
		h[s]=0;
		que.push(s);
		while (!que.empty())
		{
			const int u=que.front();
			que.pop();
			for (int i:g[u])
			{
				auto [v,c]=e[i];
				if (c>0&&h[v]==-1)
				{
					h[v]=h[u]+1;
					if (v==t) return 1;
					que.push(v);
				}
			}
		}
		return 0;
	}

	T dfs(int u,int t,T f)
	{
		if (u==t) return f;
		auto r=f;
		for (int &i=cur[u];i<int(g[u].size());i++)
		{
			const int j=g[u][i];
			auto [v,c]=e[j];
			if (c>0&&h[v]==h[u]+1)
			{
				auto a=dfs(v,t,min(r,c));
				e[j].cap-=a;
				e[j^1].cap+=a;
				r-=a;
				if (r==0) return f;
			}
		}
		return f-r;
	}

	void addEdge(int u,int v,T c)
	{
		g[u].push_back(e.size());
		e.emplace_back(v,c);
		g[v].push_back(e.size());
		e.emplace_back(u,0);
	}

	T flow(int s,int t)
	{
		T ans=0;
		while (bfs(s,t))
		{
			cur.assign(n,0);
			ans+=dfs(s,t,numeric_limits<T>::max());
		}
		return ans;
	}

	vector<bool> minCut()
	{
		vector<bool> c(n);
		for (int i=0;i<n;i++) c[i]=(h[i]!=-1);
		return c;
	}

	struct Edge
	{
		int from;
		int to;
		T cap;
		T flow;
	};

	vector<Edge> edges()
	{
		vector<Edge> a;
		for (int i=0;i<e.size();i+=2)
		{
			Edge x;
			x.from=e[i+1].to;
			x.to=e[i].to;
			x.cap=e[i].cap+e[i+1].cap;
			x.flow=e[i+1].cap;
			a.push_back(x);
		}
		return a;
	}
};
```
